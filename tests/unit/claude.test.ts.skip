import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import { launchClaudeCode } from "../../src/claude.js";
import { execa } from "execa";
import { existsSync } from "fs";

// Mock execa
vi.mock("execa", () => ({
  execa: vi.fn(),
}));

// Mock fs
vi.mock("fs", () => ({
  existsSync: vi.fn(() => true),
}));

// Mock console.log to avoid test output clutter
const consoleLogSpy = vi.spyOn(console, "log").mockImplementation(() => {});

describe("launchClaudeCode - Root User Detection", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    consoleLogSpy.mockClear();
  });

  afterEach(() => {
    // Don't restore all mocks - keep consoleLogSpy active
    vi.unstubAllGlobals();
  });

  describe("T104: Root user detection logic", () => {
    it("should detect root user when process.getuid() returns 0", async () => {
      // Mock process.getuid to return 0 (root user)
      const mockGetuid = vi.fn(() => 0);
      vi.stubGlobal("process", { ...process, getuid: mockGetuid });

      vi.mocked(execa).mockResolvedValue({
        stdout: "",
        stderr: "",
        exitCode: 0,
      } as any);

      await launchClaudeCode("/test/path", { skipPermissions: true });

      // Verify execa was called with IS_SANDBOX=1 in env
      expect(execa).toHaveBeenCalledWith(
        "bunx",
        expect.arrayContaining(["@anthropic-ai/claude-code@latest"]),
        expect.objectContaining({
          env: expect.objectContaining({
            IS_SANDBOX: "1",
          }),
        }),
      );

      vi.unstubAllGlobals();
    });

    it("should not detect root user when process.getuid() returns non-zero", async () => {
      // Mock process.getuid to return 1000 (non-root user)
      const mockGetuid = vi.fn(() => 1000);
      vi.stubGlobal("process", { ...process, getuid: mockGetuid });

      vi.mocked(execa).mockResolvedValue({
        stdout: "",
        stderr: "",
        exitCode: 0,
      } as any);

      await launchClaudeCode("/test/path", { skipPermissions: true });

      // Verify execa was called without IS_SANDBOX=1
      expect(execa).toHaveBeenCalledWith(
        "bunx",
        expect.arrayContaining(["@anthropic-ai/claude-code@latest"]),
        expect.objectContaining({
          env: process.env,
        }),
      );

      vi.unstubAllGlobals();
    });

    it("should handle environments where process.getuid() is not available", async () => {
      // Mock process without getuid (e.g., Windows)
      vi.stubGlobal("process", { ...process, getuid: undefined });

      vi.mocked(execa).mockResolvedValue({
        stdout: "",
        stderr: "",
        exitCode: 0,
      } as any);

      await launchClaudeCode("/test/path", { skipPermissions: true });

      // Verify execa was called without IS_SANDBOX=1 (fallback to non-root)
      expect(execa).toHaveBeenCalledWith(
        "bunx",
        expect.arrayContaining(["@anthropic-ai/claude-code@latest"]),
        expect.objectContaining({
          env: process.env,
        }),
      );

      vi.unstubAllGlobals();
    });
  });

  describe("T105: IS_SANDBOX=1 set when skipPermissions=true and root", () => {
    it("should set IS_SANDBOX=1 when both root user and skipPermissions=true", async () => {
      // Mock root user
      const mockGetuid = vi.fn(() => 0);
      vi.stubGlobal("process", { ...process, getuid: mockGetuid });

      vi.mocked(execa).mockResolvedValue({
        stdout: "",
        stderr: "",
        exitCode: 0,
      } as any);

      await launchClaudeCode("/test/path", { skipPermissions: true });

      // Verify IS_SANDBOX=1 is set
      expect(execa).toHaveBeenCalledWith(
        "bunx",
        expect.arrayContaining([
          "@anthropic-ai/claude-code@latest",
          "--dangerously-skip-permissions",
        ]),
        expect.objectContaining({
          env: expect.objectContaining({
            IS_SANDBOX: "1",
          }),
        }),
      );

      vi.unstubAllGlobals();
    });
  });

  describe("T106: IS_SANDBOX=1 not set when skipPermissions=false", () => {
    it("should not set IS_SANDBOX=1 when skipPermissions=false even if root", async () => {
      // Mock root user
      const mockGetuid = vi.fn(() => 0);
      vi.stubGlobal("process", { ...process, getuid: mockGetuid });

      vi.mocked(execa).mockResolvedValue({
        stdout: "",
        stderr: "",
        exitCode: 0,
      } as any);

      await launchClaudeCode("/test/path", { skipPermissions: false });

      // Verify IS_SANDBOX=1 is NOT set
      expect(execa).toHaveBeenCalledWith(
        "bunx",
        expect.arrayContaining(["@anthropic-ai/claude-code@latest"]),
        expect.objectContaining({
          env: process.env,
        }),
      );

      // Verify --dangerously-skip-permissions is NOT in args
      expect(execa).toHaveBeenCalledWith(
        "bunx",
        expect.not.arrayContaining(["--dangerously-skip-permissions"]),
        expect.anything(),
      );

      vi.unstubAllGlobals();
    });

    it("should not set IS_SANDBOX=1 when skipPermissions is undefined", async () => {
      // Mock root user
      const mockGetuid = vi.fn(() => 0);
      vi.stubGlobal("process", { ...process, getuid: mockGetuid });

      vi.mocked(execa).mockResolvedValue({
        stdout: "",
        stderr: "",
        exitCode: 0,
      } as any);

      await launchClaudeCode("/test/path", {});

      // Verify IS_SANDBOX=1 is NOT set
      expect(execa).toHaveBeenCalledWith(
        "bunx",
        expect.arrayContaining(["@anthropic-ai/claude-code@latest"]),
        expect.objectContaining({
          env: process.env,
        }),
      );

      vi.unstubAllGlobals();
    });
  });

  describe("T203-T205: Warning message display", () => {
    it("T204: should display warning message when root user and skipPermissions=true", async () => {
      // Mock root user
      const mockGetuid = vi.fn(() => 0);
      vi.stubGlobal("process", { ...process, getuid: mockGetuid });

      vi.mocked(execa).mockResolvedValue({
        stdout: "",
        stderr: "",
        exitCode: 0,
      } as any);

      await launchClaudeCode("/test/path", { skipPermissions: true });

      // Verify warning messages are displayed
      expect(consoleLogSpy).toHaveBeenCalledWith(
        expect.stringContaining("⚠️  Skipping permissions check"),
      );
      expect(consoleLogSpy).toHaveBeenCalledWith(
        expect.stringContaining(
          "⚠️  Docker/サンドボックス環境として実行中（IS_SANDBOX=1）",
        ),
      );

      vi.unstubAllGlobals();
    });

    it("T205: should not display sandbox warning when non-root user", async () => {
      // Mock non-root user
      const mockGetuid = vi.fn(() => 1000);
      vi.stubGlobal("process", { ...process, getuid: mockGetuid });

      vi.mocked(execa).mockResolvedValue({
        stdout: "",
        stderr: "",
        exitCode: 0,
      } as any);

      consoleLogSpy.mockClear();

      await launchClaudeCode("/test/path", { skipPermissions: true });

      // Verify sandbox warning is NOT displayed
      expect(consoleLogSpy).toHaveBeenCalledWith(
        expect.stringContaining("⚠️  Skipping permissions check"),
      );
      expect(consoleLogSpy).not.toHaveBeenCalledWith(
        expect.stringContaining(
          "⚠️  Docker/サンドボックス環境として実行中（IS_SANDBOX=1）",
        ),
      );

      vi.unstubAllGlobals();
    });

    it("should not display any warning when skipPermissions=false", async () => {
      // Mock root user
      const mockGetuid = vi.fn(() => 0);
      vi.stubGlobal("process", { ...process, getuid: mockGetuid });

      vi.mocked(execa).mockResolvedValue({
        stdout: "",
        stderr: "",
        exitCode: 0,
      } as any);

      consoleLogSpy.mockClear();

      await launchClaudeCode("/test/path", { skipPermissions: false });

      // Verify no skip permissions warnings are displayed
      expect(consoleLogSpy).not.toHaveBeenCalledWith(
        expect.stringContaining("⚠️  Skipping permissions check"),
      );
      expect(consoleLogSpy).not.toHaveBeenCalledWith(
        expect.stringContaining(
          "⚠️  Docker/サンドボックス環境として実行中（IS_SANDBOX=1）",
        ),
      );

      vi.unstubAllGlobals();
    });
  });
});
