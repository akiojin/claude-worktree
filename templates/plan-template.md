# 実装計画: [FEATURE]

**ブランチ**: `[###-feature-name]` | **日付**: [DATE] | **仕様**: [link]
**入力**: `/specs/[###-feature-name]/spec.md` の機能仕様

## 実行フロー（/plan コマンドの範囲）
```
1. 入力パスから機能仕様を読み込む
   → 見つからない場合: ERROR "{path} に機能仕様がありません"
2. 技術コンテキストを埋める（NEEDS CLARIFICATION を走査）
   → 文脈からプロジェクト種別を検出（web=frontend+backend、mobile=app+api）
   → 種別に基づき構成方針（Structure Decision）を設定
3. 下記の「憲章チェック」を評価
   → 違反がある場合: 複雑性トラッキングに記録
   → 正当化できない場合: ERROR "まずアプローチを単純化してください"
   → 進捗トラッキングを更新: 初回の憲章チェック
4. フェーズ0を実行 → research.md
   → NEEDS CLARIFICATION が残る場合: ERROR "不明点を解消してください"
5. フェーズ1を実行 → contracts、data-model.md、quickstart.md、エージェント別テンプレートファイル（例: Claude Code は `CLAUDE.md`、GitHub Copilot は `.github/copilot-instructions.md`、Gemini CLI は `GEMINI.md`）
6. 憲章チェックを再評価
   → 新たな違反があれば: 設計をリファクタしフェーズ1へ戻る
   → 進捗トラッキングを更新: 設計後の憲章チェック
7. フェーズ2の計画 → タスク生成アプローチを記述（tasks.md は作成しない）
8. STOP - /tasks コマンドの準備完了
```

**重要**: /plan コマンドは手順7で停止します。フェーズ2〜4は別コマンドが実行します:
- フェーズ2: /tasks コマンドが tasks.md を生成
- フェーズ3-4: 実装の実行（手動またはツール）

## 要約
[機能仕様からの抜粋: 主要要件 + 調査に基づく技術アプローチ]

## 技術コンテキスト
**言語/バージョン**: [例: Python 3.11, Swift 5.9, Rust 1.75 または NEEDS CLARIFICATION]  
**主要依存**: [例: FastAPI, UIKit, LLVM または NEEDS CLARIFICATION]  
**ストレージ**: [該当する場合: PostgreSQL, CoreData, ファイル など／N/A]  
**テスト**: [例: pytest, XCTest, cargo test または NEEDS CLARIFICATION]  
**ターゲットプラットフォーム**: [例: Linux サーバ、iOS 15+、WASM または NEEDS CLARIFICATION]
**プロジェクト種別**: [single/web/mobile - ソース構成を決定]  
**性能目標**: [ドメイン依存: 例 1000 req/s、10k lines/sec、60 fps または NEEDS CLARIFICATION]  
**制約**: [ドメイン依存: 例 p95 <200ms、メモリ <100MB、オフライン対応 等 または NEEDS CLARIFICATION]  
**規模/範囲**: [ドメイン依存: 例 1万人ユーザ、100万LOC、50画面 等 または NEEDS CLARIFICATION]

## 憲章チェック
*GATE: フェーズ0の調査前に合格必須。フェーズ1設計後に再チェック。*

**シンプルさ**:
- プロジェクト数: [#]（最大3例: api, cli, tests）
- フレームワークを直接使用？（ラッパークラス禁止）
- 単一データモデル？（シリアライズ差異がない限り DTO 禁止）
- パターン濫用を回避？（実需要の証明なしに Repository/UoW 禁止）

**アーキテクチャ**:
- すべての機能はライブラリ化？（アプリ直書き禁止）
- ライブラリ一覧: [各 name + 目的]
- ライブラリごとに CLI 提供: [--help/--version/--format を備える]
- ライブラリドキュメント: llms.txt 形式を計画？

**テスト（非交渉）**:
- RED→GREEN→リファクタのサイクル強制？（まずテストは失敗すること）
- Git の履歴に実装前のテストが残る？
- 順序: Contract→Integration→E2E→Unit を厳守？
- 実物依存を使用？（モックではなく実DB等）
- 統合テスト: 新規ライブラリ、契約変更、共有スキーマを網羅？
- 禁止事項: テスト前実装、RED フェーズ省略

**可観測性**:
- 構造化ログを含む？
- フロントのログ→バックエンド集約？（単一ストリーム）
- エラー文脈は十分？

**バージョニング**:
- バージョン番号付与？（MAJOR.MINOR.BUILD）
- 変更ごとに BUILD を増分？
- 破壊的変更の扱い？（平行テスト、移行計画）

## プロジェクト構成

### ドキュメント（本機能）
```
specs/[###-feature]/
├── plan.md              # 本ファイル（/plan コマンド出力）
├── research.md          # フェーズ0の出力（/plan コマンド）
├── data-model.md        # フェーズ1の出力（/plan コマンド）
├── quickstart.md        # フェーズ1の出力（/plan コマンド）
├── contracts/           # フェーズ1の出力（/plan コマンド）
└── tasks.md             # フェーズ2の出力（/tasks コマンド - /plan では作らない）
```

### ソースコード（リポジトリルート）
```
# オプション1: 単一プロジェクト（デフォルト）
src/
├── models/
├── services/
├── cli/
└── lib/

tests/
├── contract/
├── integration/
└── unit/

# オプション2: Web アプリ（"frontend" + "backend" を検出した場合）
backend/
├── src/
│   ├── models/
│   ├── services/
│   └── api/
└── tests/

frontend/
├── src/
│   ├── components/
│   ├── pages/
│   └── services/
└── tests/

# オプション3: モバイル + API（"iOS/Android" を検出した場合）
api/
└── [same as backend above]

ios/ or android/
└── [platform-specific structure]
```

**構成方針**: [技術コンテキストが web/mobile を示さない限りオプション1をデフォルト]

## フェーズ0: 叩き台 & 調査
1. 上記「技術コンテキスト」から不明点を抽出:
   - 各 NEEDS CLARIFICATION → 調査タスク
   - 各依存関係 → ベストプラクティスタスク
   - 各連携箇所 → パターンタスク

2. 調査エージェントを生成して配布:
   ```
   技術コンテキストの各不明点について:
     Task: "{feature context} における {unknown} の調査"
   各技術選択について:
     Task: "{domain} における {tech} のベストプラクティス調査"
   ```

3. `research.md` に所見を集約（以下の形式）:
   - 決定: [何を選んだか]
   - 根拠: [なぜそうしたか]
   - 代替案: [検討した他の案]

**出力**: すべての NEEDS CLARIFICATION を解消した research.md

## フェーズ1: 設計 & 契約
*前提: research.md 完了*

1. 機能仕様からエンティティを抽出 → `data-model.md`:
   - エンティティ名、フィールド、リレーション
   - 要件に基づくバリデーション規則
   - 状態遷移（該当する場合）

2. 機能要件から API 契約を生成:
   - 各ユーザー操作 → エンドポイント
   - 標準的な REST/GraphQL のパターンを使用
   - OpenAPI/GraphQL スキーマを `/contracts/` に出力

3. 契約に基づくコントラクトテストを生成:
   - エンドポイントごとに1テストファイル
   - リクエスト/レスポンスのスキーマを検証
   - テストは失敗状態から開始（実装はまだ行わない）

4. ユーザーストーリーからテストシナリオを抽出:
   - 各ストーリー → 統合テストのシナリオ
   - クイックスタートテスト = ストーリーの検証手順

5. エージェントファイルを漸進的に更新（O(1) 操作）:
   - `/scripts/update-agent-context.sh [claude|gemini|copilot]` を実行
   - 既存がある場合: 現在の計画からの「新規」技術のみ追加
   - マーカー間の手動追記は保持
   - 最近の変更を更新（直近3件を保持）
   - 150行未満に抑えトークン効率を確保
   - リポジトリ直下に出力

**出力**: data-model.md、/contracts/*、失敗するテスト、quickstart.md、エージェント別ファイル

## フェーズ2: タスク計画アプローチ
*この節は /tasks コマンドが実施する内容の説明です - /plan 中は実行しない*

**タスク生成戦略**:
- `/templates/tasks-template.md` をベースとして読み込む
- フェーズ1の設計ドキュメント（contracts、データモデル、quickstart）からタスク生成
- 各契約 → コントラクトテストタスク [P]
- 各エンティティ → モデル作成タスク [P]
- 各ユーザーストーリー → 統合テストタスク
- テストを通すための実装タスク

**順序戦略**:
- TDD 順: 実装前にテスト
- 依存順: モデル→サービス→UI
- 並列実行可のものに [P] を付与（独立ファイル）

**想定出力**: tasks.md に 25〜30 個の番号付き・順序付きタスク

**重要**: このフェーズは /plan ではなく /tasks コマンドが実行します

## フェーズ 3+: 将来の実装
*/plan コマンドの範囲外のフェーズです*

**フェーズ3**: タスク実行（/tasks が tasks.md を生成）  
**フェーズ4**: 実装（憲章の原則に従い tasks.md を実施）  
**フェーズ5**: 検証（テスト実行、quickstart.md 実施、性能検証）

## 複雑性トラッキング
*憲章チェックの違反を正当化する必要がある場合のみ記入*

| 逸脱内容 | 必要な理由 | より単純な代替案を却下した理由 |
|----------|------------|-----------------------------------|
| [例: 4つ目のプロジェクト] | [現在の必要性] | [3プロジェクトでは不十分な理由] |
| [例: Repository パターン] | [具体的な課題] | [DB 直接アクセスでは不十分な理由] |

## 進捗トラッキング
*実行フロー中に本チェックリストを更新*

**フェーズ状況**:
- [ ] フェーズ0: 調査完了（/plan）
- [ ] フェーズ1: 設計完了（/plan）
- [ ] フェーズ2: タスク計画完了（/plan - アプローチ記述のみ）
- [ ] フェーズ3: タスク生成（/tasks）
- [ ] フェーズ4: 実装完了
- [ ] フェーズ5: 検証合格

**ゲート状況**:
- [ ] 初回の憲章チェック: PASS
- [ ] 設計後の憲章チェック: PASS
- [ ] すべての NEEDS CLARIFICATION を解消
- [ ] 複雑性の逸脱を記録

---
*Constitution v2.1.1 に基づく — `/memory/constitution.md` を参照*
