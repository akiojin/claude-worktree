# 実装計画: PR自動マージ機能

**仕様ID**: `SPEC-cff08403` | **日付**: 2025-10-25 | **仕様書**: [spec.md](./spec.md)
**入力**: `/specs/SPEC-cff08403/spec.md` からの機能仕様

**注**: このテンプレートは `/speckit.plan` コマンドによって記入されます。実行ワークフローについては `.specify/templates/commands/plan.md` を参照してください。

## 概要

PR自動マージ機能は、GitHub Actionsを使用してCIが成功し競合がない場合に、すべてのPRを自動的にMerge commitでマージします。開発者はマージ完了を待つ必要がなくなり、開発速度が向上します。

## 技術コンテキスト

**言語/バージョン**: YAML（GitHub Actions Workflow）
**主要な依存関係**: GitHub Actions、GitHub CLI（gh）、GitHub API
**ストレージ**: N/A（GitHub APIを使用）
**テスト**: 実際のPRでの統合テスト、GitHub Actionsワークフローのテスト
**ターゲットプラットフォーム**: GitHub Actions（ubuntu-latest）
**プロジェクトタイプ**: CI/CDワークフロー
**パフォーマンス目標**: 最後のCIワークフロー完了から5分以内に自動マージ
**制約**: GitHub APIレート制限、GitHub Actions実行時間制限（最大6時間）、必要な権限（contents: write, pull-requests: write）
**スケール/範囲**: すべてのPR（main、developブランチへの全PR）

## 原則チェック

*ゲート: フェーズ0の調査前に合格する必要があります。フェーズ1の設計後に再チェック。*

**注**: constitution.mdがテンプレートのままのため、具体的な原則チェックは実施できません。ただし、一般的なベストプラクティスに従って実装します：

- ✅ **シンプルさ**: ワークフローは最小限の設定で動作
- ✅ **安全性**: CIの成功と競合なしを必須条件とする
- ✅ **可観測性**: すべての決定をログに記録
- ✅ **最小権限**: 必要最小限の権限のみ使用

## プロジェクトファイル構造

### ドキュメント（この機能）

```text
specs/SPEC-cff08403/
├── plan.md              # このファイル（/speckit.plan コマンド出力）
├── research.md          # フェーズ0出力（/speckit.plan コマンド）
├── data-model.md        # フェーズ1出力（/speckit.plan コマンド）
├── quickstart.md        # フェーズ1出力（/speckit.plan コマンド）
├── contracts/           # フェーズ1出力（/speckit.plan コマンド）
└── tasks.md             # フェーズ2出力（/speckit.tasks コマンド - /speckit.planでは作成されません）
```

### ソースコード（リポジトリルート）

```text
.github/workflows/
├── auto-merge.yml       # 新規: 自動マージワークフロー
├── test.yml             # 既存: テストワークフロー（依存関係）
└── lint.yml             # 既存: Lintワークフロー（依存関係）
```

## フェーズ0: 調査（技術スタック選定）

**目的**: 要件に基づいて技術スタックを決定し、既存のコードパターンを理解する

**出力**: `specs/SPEC-cff08403/research.md`

### 調査項目

1. **既存のコードベース分析**
   - 既存のCIワークフロー（Test、Lint）の構造と依存関係
   - GitHub Actionsのトリガーパターン（workflow_run）
   - ブランチ保護ルールの設定状況

2. **技術的決定**
   - workflow_runトリガーの使用方法
   - GitHub CLIとGitHub APIの選択基準
   - マージ状態の確認方法
   - エラーハンドリング戦略

3. **制約と依存関係**
   - GitHub APIのレート制限への対応
   - 複数ワークフローの完了待機方法
   - ドラフトPRの除外ロジック

## フェーズ1: 設計（アーキテクチャと契約）

**目的**: 実装前に技術設計を定義する

**出力**:
- `specs/SPEC-cff08403/data-model.md`
- `specs/SPEC-cff08403/quickstart.md`
- `specs/SPEC-cff08403/contracts/` （該当する場合）

### 1.1 データモデル設計

**ファイル**: `data-model.md`

主要なエンティティとその関係を定義：
- PRの状態モデル
- CIワークフローの状態モデル
- マージ条件の評価ロジック

### 1.2 クイックスタートガイド

**ファイル**: `quickstart.md`

開発者向けの簡潔なガイド：
- 自動マージ機能の有効化方法
- ローカルでのワークフローテスト方法
- トラブルシューティング手順

### 1.3 契約/インターフェース

**ディレクトリ**: `contracts/`

GitHub Actionsワークフローの契約を定義：
- workflow_runイベントペイロード仕様
- GitHub CLI/APIレスポンス形式
- ワークフロー間の依存関係定義

## フェーズ2: タスク生成

**次のステップ**: `/speckit.tasks` コマンドを実行

**入力**: このプラン + 仕様書 + 設計ドキュメント

**出力**: `specs/SPEC-cff08403/tasks.md` - 実装のための実行可能なタスクリスト

## 実装戦略

### 優先順位付け

ユーザーストーリーの優先度に基づいて実装：
1. **P1 - 自動マージの基本フロー**: CI成功時の自動マージ（最も重要）
2. **P1 - エラー処理とスキップ**: 安全性の確保（同じく重要）
3. **P2 - 複数ワークフローの同期**: 複数CIワークフローへの対応

### 独立したデリバリー

各ユーザーストーリーは独立して実装・テスト・デプロイ可能：
- ストーリー1を完了 → 単一ワークフロー完了時の自動マージMVP
- ストーリー2を追加 → エラー処理を含む安全なMVP
- ストーリー3を追加 → 完全な複数ワークフロー対応

## テスト戦略

### 統合テスト

- **テストPRの作成**: 実際にPRを作成してワークフローをトリガー
- **CI成功シナリオ**: すべてのCIが成功した場合の自動マージ検証
- **CI失敗シナリオ**: 一部のCIが失敗した場合のスキップ検証
- **競合シナリオ**: マージ競合がある場合のスキップ検証
- **ドラフトPRシナリオ**: ドラフトPRが除外されることの検証

### エンドツーエンドテスト

- 実際のブランチとPRを使用した完全なワークフロー検証
- ログ出力の確認
- マージ完了までの時間測定

## リスクと緩和策

### 技術的リスク

1. **GitHub APIレート制限**:
   - **緩和策**: 必要最小限のAPI呼び出しに制限、エラーハンドリングで適切に処理

2. **workflow_runトリガーの遅延**:
   - **緩和策**: 5分以内という目標に余裕を持たせ、遅延を許容

3. **複数ワークフローの同期タイミング**:
   - **緩和策**: 最後に完了したワークフローで全体の状態を確認

### 依存関係リスク

1. **既存CIワークフローの変更**:
   - **緩和策**: ワークフロー名での識別を使用、柔軟な設定

2. **GitHub Actions機能の変更**:
   - **緩和策**: 公式ドキュメントに基づく標準的な実装

## 次のステップ

1. ✅ フェーズ0完了: 調査と技術スタック決定 → [research.md](./research.md)
2. ✅ フェーズ1完了: 設計とアーキテクチャ定義 → [data-model.md](./data-model.md), [quickstart.md](./quickstart.md), [contracts/](./contracts/)
3. ⏭️ `/speckit.tasks` を実行してタスクを生成
4. ⏭️ `/speckit.implement` で実装を開始
