# 実装計画: ブランチ選択カーソル視認性向上

**仕様ID**: `SPEC-822a2cbf` | **日付**: 2025-10-25 | **仕様書**: [spec.md](./spec.md)
**入力**: `specs/SPEC-822a2cbf/spec.md` からの機能仕様

## 概要

メイン画面のブランチ選択リストをテーブル形式からアイコン＋配置インジケータのリスト表示へ刷新する。各行は「ブランチ種別アイコン」「ワークツリーアイコン（任意）」「変更状態アイコン（任意）」「配置インジケータ枠」「ブランチ名」を固定幅で並べ、ブランチ名はプレフィックスを取り除いた形（例: `origin/main` → `main`）で表示する。配置枠は左がローカル（`L`）、右がリモート（`R`）、ローカルがなくリモートのみの場合は雲アイコン（`☁`）、該当しない場合は空白とする。ローカルとリモートが両方存在するブランチは1行のみ表示し、左に`L`、右に`R`を並べる。カラー非対応環境では `>`（スペース付き） プレフィックスのみにフォールバックし、整列が崩れないようにする。ショートカット遷移後のフォーカス保持も引き続き保証する。

## 技術コンテキスト

<!--
  対応必要: このセクションの内容をプロジェクトの技術詳細で置き換えてください。
  ここで示されている構造は、反復プロセスをガイドするための助言的な役割を果たします。
-->

**言語/バージョン**: TypeScript (ES2022) / Bun 1.x 実行
**主要な依存関係**: `@inquirer/core`, `@inquirer/prompts`, `chalk`, `string-width`
**ストレージ**: N/A（CLIのみ）
**テスト**: `vitest`（既存UIユニットテストが無いため、新規テストはスナップショット中心を想定）
**ターゲットプラットフォーム**: POSIX互換シェル上のターミナル（モノクロ含む）
**プロジェクトタイプ**: 単一CLIプロジェクト（`src/`配下）
**パフォーマンス目標**: 入力後200ms以内で行描画を更新（仕様 FR-002）
**制約**: 80桁想定のターミナル幅で崩れない。ANSI非対応時も `>`（スペース付き） などのプレフィックスで識別可能。
**スケール/範囲**: 数百ブランチの一覧でも操作性を維持（既存ループ構造を再利用）

## 原則チェック

_ゲート: フェーズ0の調査前に合格する必要があります。フェーズ1の設計後に再チェック。_

- シンプルな実装を優先し、過剰なカスタムレンダリングを避ける
- CLI操作の直感性重視: ショートカットと視覚手掛かりを統一
- 既存コードのパターンを尊重し、最小限の変更で改善

## プロジェクト構造

### ドキュメント（この機能）

```text
specs/SPEC-822a2cbf/
├── plan.md
├── spec.md
├── checklists/
└── (必要に応じて) research.md, data-model.md, quickstart.md, contracts/, tasks.md
```

### ソースコード（リポジトリルート）

```text
src/
├── ui/
│   ├── display.ts      # 画面描画ロジック
│   ├── prompts.ts      # ブランチ選択含むプロンプト
│   └── table.ts        # 一覧描画補助
├── utils.ts
└── worktree.ts
tests/
└── [UI関連テスト（必要に応じ追加）]
```

## フェーズ0: 調査（技術スタック選定）

**目的**: 要件に基づいて技術スタックを決定し、既存のコードパターンを理解する

**出力**: `specs/[SPEC-xxxxxxxx]/research.md`

### 調査項目

1. **既存のコードベース分析**
   - `selectBranchWithShortcuts` のレンダリング処理とキー操作ハンドリングの確認
   - `display.ts` でのヘッダー/ガイダンス文言と `chalk` の使い方を調査
   - ANSIカラー有効判定ロジック（`chalk.level` など）とモノクロ対応の現状把握

2. **技術的決定**
   - 強調表示の実装手段: 背景色ハイライトを基本とし、モノクロ時は `>`（スペース付き） プレフィックスで代替
   - モノクロフォールバックの条件分岐（chalkサポートレベル判定）
   - 既存ショートカット遷移から戻る際の選択状態保持方法（状態変数の確認）

3. **制約と依存関係**
   - `@inquirer/core` のカスタムプロンプト描画の仕様内で対応させる

- 既存のレイアウト依存コードを洗い出し、リスト形式へ置き換える際に整列基準を再設計

## フェーズ1: 設計（アーキテクチャと契約）

**目的**: アイコン＋行色リストでの描画ルール（固定幅アイコン枠、行カラー、フォールバック）を詳細化し、関連ガイダンス／ドキュメント更新方針をまとめる

**出力**: 必要に応じ `data-model.md` や `quickstart.md` を補完（今回データモデルは簡易メモで足りる想定）

### 1.1 データモデル設計

**ファイル**: `data-model.md`

既存`BranchInfo`等に新規プロパティは不要見込み。必要に応じ、種別アイコンや状態情報を算出するヘルパー関数の設計を記録。

### 1.2 クイックスタートガイド

**ファイル**: `quickstart.md`

アイコン表現や行色の意味を README に反映する手順、モノクロ環境での挙動説明を記載。

> ⚠️ Markdown整形ヒント
>
> - 入れ子のリストは 2 スペースでインデントする（`-` の後に 2 スペース）
> - URL は必ず `[表示名](https://example.com)` の形式で記述し、裸URLは避ける
> - コードブロックやコマンド例には適切な言語ラベルを付ける（例: ```bash）

### 1.3 契約/インターフェース（該当する場合）

**ディレクトリ**: `contracts/`

外部契約は不要。アイコン定義と表示ルールを簡易リファレンスとして整理する程度で良い。

## フェーズ2: タスク生成

**次のステップ**: `/speckit.tasks` コマンドを実行

**入力**: このプラン + 仕様書 + 設計ドキュメント

**出力**: `specs/[SPEC-xxxxxxxx]/tasks.md` - 実装のための実行可能なタスクリスト

## 実装戦略

### 優先順位付け

ユーザーストーリーの優先度に基づいて実装：

1. **P1**: 最も重要 - 最初に実装
2. **P2**: 重要 - P1の後
3. **P3**: 補完的 - 最後に

### 独立したデリバリー

各ユーザーストーリーは独立して実装・テスト・デプロイ可能：

- ストーリー1を完了 → デプロイ可能なMVP
- ストーリー2を追加 → 拡張MVP
- ストーリー3を追加 → 完全な機能

## テスト戦略

- **ユニットテスト**: `selectBranchWithShortcuts` の描画結果をモックで検証（アイコン整列・行色・フォールバックの挙動）
- **統合テスト**: 簡易的に CLI をモックして強調表示文字列をスナップショットチェック
- **エンドツーエンドテスト**: 手動操作でブランチ選択→ショートカット→復帰の流れを確認
- **パフォーマンステスト**: 対象外（既存ループの計算量変化なし）

## リスクと緩和策

### 技術的リスク

1. **chalk背景色がテーマによって読みにくい**
   - **緩和策**: `chalk.supportsColor` に応じ `>`（スペース付き） プレフィックスのみのフォールバックを継続し、アイコン整列が崩れないよう空白パディングを徹底

2. **カスタムプロンプト改修でスクロール制御に影響する**
   - **緩和策**: 既存選択インデックス処理を変更しない。表示文字列の整形のみを調整し、テストで回帰確認

### 依存関係リスク

1. **`@inquirer/core` のアップデートに伴う描画仕様変更**
   - **緩和策**: 既存バージョン範囲での動作に留め、将来のアップデート時はスナップショットテストで検知

## 次のステップ

1. ⏳ フェーズ0: `prompts.ts` / `display.ts` の現在実装をリサーチ
2. ⏳ フェーズ1: 強調表示の描画方式とフォールバックルールを詳細化
3. ⏭️ `/speckit.tasks` を実行してタスクを生成
4. ⏭️ `/speckit.implement` で実装を開始
