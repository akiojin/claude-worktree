# 実装計画: アプリケーションバージョン表示機能

**仕様ID**: `SPEC-207ccae7` | **日付**: 2025-10-31 | **仕様書**: [spec.md](./spec.md)
**入力**: `/specs/SPEC-207ccae7/spec.md` からの機能仕様

**注**: このテンプレートは `/speckit.plan` コマンドによって記入されます。実行ワークフローについては `.specify/templates/commands/plan.md` を参照してください。

## 概要

アプリケーションのバージョン情報を2つの方法で表示する機能を実装します：

1. **CLIフラグ（P1）**: `--version` / `-v` フラグでバージョンを即座に標準出力
2. **UIヘッダー（P2）**: メイン画面のヘッダーコンポーネントにバージョン情報を表示

バージョン情報はpackage.jsonから動的に取得し、既存の`getPackageVersion()`関数を活用します。実装はシンプルさを追求し、既存のHeaderコンポーネントとCLI引数パース処理を拡張する形で実現します。

## 技術コンテキスト

**言語/バージョン**: TypeScript 5.8.3、Bun 1.0+ (ランタイム)
**主要な依存関係**:
- React 19.2.0（UIフレームワーク）
- Ink.js 6.3.1（CLI TUIフレームワーク）
- Chalk 5.4.1（ターミナル出力の装飾）
**ストレージ**: N/A（package.jsonのみ参照）
**テスト**: Bun test（既存のテストフレームワーク）
**ターゲットプラットフォーム**: Node.js 18+ / Bun 1.0+ 環境
**プロジェクトタイプ**: 単一CLIアプリケーション（TUI対応）
**パフォーマンス目標**: バージョン取得は1秒以内、UI起動時のオーバーヘッドは最小限
**制約**:
- 既存のHeaderコンポーネントとの互換性維持
- package.jsonが存在しない環境での適切なエラーハンドリング
- CLI標準の動作（--version実行後は即座に終了）
**スケール/範囲**: 小規模機能（2ファイル修正、1コンポーネント拡張）

## 原則チェック

*ゲート: フェーズ0の調査前に合格する必要があります。フェーズ1の設計後に再チェック。*

### CLAUDE.md開発指針との整合性

✅ **シンプルさの追求**: 既存の`getPackageVersion()`関数を再利用し、最小限のコード変更で実現
✅ **ユーザビリティと開発者体験の品質**: CLIフラグとUIヘッダーの両方でバージョンを提供し、標準的なCLI動作に準拠
✅ **既存ファイルの優先改修**: 新規ファイル作成ではなく、既存のHeader.tsxとindex.tsを拡張
✅ **エラーハンドリング**: package.json読み取り失敗時もアプリケーションをクラッシュさせない
✅ **Spec Kit準拠**: SDD/TDDワークフローに従い、仕様→計画→タスク→実装の流れを遵守

### 品質ゲート

- [x] 実装の複雑さが最小限に抑えられている
- [x] ユーザビリティが妥協されていない
- [x] 既存の設計パターンとの整合性がある
- [x] エラーハンドリングが適切に設計されている
- [x] TDD/SDD手法に準拠している

## プロジェクト構造

### ドキュメント（この機能）

```text
specs/SPEC-207ccae7/
├── spec.md              # 機能仕様書（完了）
├── plan.md              # このファイル（/speckit.plan コマンド出力）
├── research.md          # フェーズ0出力（/speckit.plan コマンド）
├── data-model.md        # フェーズ1出力（/speckit.plan コマンド）
├── quickstart.md        # フェーズ1出力（/speckit.plan コマンド）
├── contracts/           # フェーズ1出力（該当する場合）
├── checklists/          # 品質チェックリスト
│   └── requirements.md  # 仕様品質チェックリスト（完了）
└── tasks.md             # フェーズ2出力（/speckit.tasks コマンド）
```

### ソースコード（リポジトリルート）

```text
src/
├── index.ts                           # CLIエントリーポイント（修正対象）
├── utils.ts                           # ユーティリティ関数（getPackageVersion）
└── ui/
    └── components/
        ├── App.tsx                    # メインアプリケーション
        └── parts/
            └── Header.tsx             # ヘッダーコンポーネント（修正対象）
```

## フェーズ0: 調査（技術スタック選定）

**目的**: 既存のコードベースパターンを理解し、拡張方法を決定する

**出力**: `specs/SPEC-207ccae7/research.md`

### 調査項目

1. **既存のコードベース分析**
   - 既存の`getPackageVersion()`関数の実装詳細と動作
   - Header.tsxコンポーネントのプロップ構造とレンダリングロジック
   - index.tsのCLI引数パース処理（現在の`--help`の実装方法）
   - 各画面コンポーネント（BranchListScreen、BranchCreatorScreenなど）でのHeaderの使用方法

2. **技術的決定**
   - Headerコンポーネントへのバージョンプロップ追加方法
   - CLI引数の検出とバージョン表示関数の実装方法
   - エラーハンドリング戦略（package.json読み取り失敗時）
   - バージョン表示フォーマット（"Claude Worktree v1.12.3"形式）

3. **制約と依存関係**
   - 既存のHeaderコンポーネントAPIとの互換性維持
   - React.memoによる最適化への影響
   - Ink.jsのレンダリングパフォーマンスへの影響
   - package.jsonの配置場所の仮定

## フェーズ1: 設計（アーキテクチャと契約）

**目的**: 実装前に技術設計を定義する

**出力**:
- `specs/SPEC-207ccae7/data-model.md`
- `specs/SPEC-207ccae7/quickstart.md`
- `specs/SPEC-207ccae7/contracts/` （必要に応じて）

### 1.1 データモデル設計

**ファイル**: `data-model.md`

主要なエンティティとその関係を定義：

1. **バージョン情報エンティティ**
   - ソース: package.jsonの`version`フィールド
   - フォーマット: セマンティックバージョニング（major.minor.patch）
   - 型定義: `string | null`（取得失敗時はnull）

2. **Headerコンポーネントプロップス**
   - 既存プロップ: title, titleColor, dividerChar, showDivider, width
   - 新規プロップ: `version?: string | null`（オプショナル）

3. **CLI引数構造**
   - 既存: `--help` / `-h`
   - 新規: `--version` / `-v`

### 1.2 クイックスタートガイド

**ファイル**: `quickstart.md`

開発者向けの簡潔なガイド：
- セットアップ手順（依存関係インストール、ビルド）
- 開発ワークフロー（ローカル実行、テスト実行）
- よくある操作（バージョン確認、UIでの表示確認）
- トラブルシューティング（package.json読み取りエラーなど）

### 1.3 契約/インターフェース（該当する場合）

**ディレクトリ**: `contracts/`

この機能では外部APIや複雑な契約は不要ですが、以下を定義します：

- **HeaderPropsインターフェース拡張**: TypeScript型定義
- **CLIフラグ仕様**: `--version` / `-v` の動作仕様
- **エラーハンドリング契約**: package.json読み取り失敗時の動作

## フェーズ2: タスク生成

**次のステップ**: `/speckit.tasks` コマンドを実行

**入力**: このプラン + 仕様書 + 設計ドキュメント

**出力**: `specs/SPEC-207ccae7/tasks.md` - 実装のための実行可能なタスクリスト

## 実装戦略

### 優先順位付け

ユーザーストーリーの優先度に基づいて実装：

1. **P1 - CLIフラグでバージョン確認**: 最も重要 - 最初に実装
   - `showVersion()`関数の実装
   - CLI引数パース処理の追加
   - エラーハンドリングの実装

2. **P2 - UIヘッダーでバージョン確認**: P1の後に実装
   - Header.tsxへのversionプロップ追加
   - 各画面コンポーネントでのバージョン取得と渡し
   - レンダリングロジックの実装

### 独立したデリバリー

各ユーザーストーリーは独立して実装・テスト・デプロイ可能：

- **P1完了**: CLIフラグ機能が動作 → デプロイ可能なMVP
- **P2追加**: UIヘッダー機能が追加 → 完全な機能

### 実装アプローチ

**シンプルさの追求**:
- 既存の`getPackageVersion()`関数を再利用（新規実装不要）
- Headerコンポーネントはプロップ追加のみ（最小限の変更）
- CLI引数パースは既存のパターンに倣う（一貫性維持）

**開発者体験の品質**:
- TypeScript型定義を適切に更新
- エラーメッセージは明確でユーザーフレンドリー
- ドキュメントは簡潔で実用的

## テスト戦略

### ユニットテスト

- `getPackageVersion()`関数のテスト（既存のテストケースがあれば拡張）
  - 正常系: package.jsonが存在し、versionフィールドがある
  - 異常系: package.jsonが存在しない
  - 異常系: versionフィールドが存在しない

- `showVersion()`関数のテスト
  - バージョン取得成功時の標準出力
  - バージョン取得失敗時のエラーメッセージ

- Headerコンポーネントのテスト
  - versionプロップありの場合のレンダリング
  - versionプロップなしの場合のレンダリング
  - versionがnullの場合のレンダリング

### 統合テスト

- CLI実行テスト
  - `claude-worktree --version` の実行と出力確認
  - `claude-worktree -v` の実行と出力確認
  - バージョン表示後の正常終了確認

- UIテスト
  - アプリケーション起動時のヘッダー表示確認
  - 各画面でのバージョン表示の一貫性確認

### エンドツーエンドテスト

- 実際のユーザーシナリオに基づくテスト
  - ユーザーストーリー1の受け入れシナリオ（P1）
  - ユーザーストーリー2の受け入れシナリオ（P2）

## リスクと緩和策

### 技術的リスク

1. **package.jsonのパス解決失敗**
   - **説明**: 実行環境によってpackage.jsonの相対パスが異なる可能性
   - **緩和策**: 既存の`getPackageVersion()`の実装を信頼し、エラーハンドリングを強化

2. **Headerコンポーネントのレンダリングパフォーマンス**
   - **説明**: バージョン情報の追加がUIレンダリングに影響する可能性
   - **緩和策**: React.memoを維持し、バージョン取得は起動時のみ実行

3. **CLI引数パース処理の競合**
   - **説明**: 既存の引数パース処理と新しい--versionフラグの競合
   - **緩和策**: 既存の--helpパターンに倣い、早期リターンで他の処理をスキップ

### 依存関係リスク

1. **package.jsonの存在に依存**
   - **説明**: package.jsonが存在しない環境ではバージョン表示が不可能
   - **緩和策**: 適切なフォールバックメッセージを表示し、アプリケーションは継続動作

2. **Bunランタイムとの互換性**
   - **説明**: Bunランタイムでのファイル読み取り動作が異なる可能性
   - **緩和策**: 既存のutils.tsの実装がBun対応済みなので問題なし

## 次のステップ

1. ⏭️ フェーズ0: research.mdを生成（調査と技術スタック決定）
2. ⏭️ フェーズ1: data-model.md、quickstart.md、contracts/を生成
3. ⏭️ `/speckit.tasks` を実行してタスクを生成
4. ⏭️ `/speckit.implement` で実装を開始
