# 調査レポート: Codex CLI対応実装

**機能**: claude-worktree起動時のツール選択  
**日付**: 2025-01-06  
**ステータス**: 完了

## 調査項目と決定事項

### 1. Codex CLIの利用可能性チェック方法

**決定**: `which codex` コマンドでパスの存在を確認
**根拠**: 
- 標準的なUnixコマンドでクロスプラットフォーム対応
- Node.jsの `child_process.exec` で簡単に実行可能
- 実行可能ファイルの存在を高速に確認

**代替案**:
- `codex --version` の実行: 時間がかかる可能性
- パッケージマネージャのグローバル状態確認: 実装負荷が高く、環境差異が大きい

### 2. 選択の永続化方法

**決定**: ホームディレクトリの `.claude-worktree/config.json` に保存
**根拠**:
- ユーザー単位の設定として適切
- JSONフォーマットで読み書きが簡単
- 他のCLIツールの慣例に従う

**代替案**:
- プロジェクトローカル設定: プロジェクト間で共有されない
- 環境変数: 永続化が困難
- セッションのみ: UXが劣る

### 3. コマンドラインオプション設計

**決定**: 以下のオプションを実装
```bash
claude-worktree                    # 対話型選択
claude-worktree --tool claude      # Claude Code直接指定
claude-worktree --tool codex       # Codex CLI直接指定
claude-worktree --reset-default    # デフォルト設定をリセット
claude-worktree --help            # ヘルプ表示
claude-worktree --version         # バージョン表示

# ツール固有オプションのパススルー
claude-worktree --tool claude -- -r    # Claude Codeに -r オプションを渡す
claude-worktree --tool claude -- -c    # Claude Codeに -c オプションを渡す
claude-worktree --tool codex -- --continue   # Codex CLIに --continue オプションを渡す
claude-worktree --tool codex -- --resume     # Codex CLIに --resume オプションを渡す
```

**根拠**:
- 柔軟性と使いやすさのバランス
- CI/CD環境での自動化対応
- 標準的なCLI慣例に準拠
- ツール固有オプションの透過的なサポート

**代替案**:
- サブコマンド方式: 複雑すぎる
- 環境変数のみ: 発見しにくい

### 3.1. ツール固有オプションの違い

**Claude Code**:
- `-r`: リジューム（前回のセッションを再開）
- `-c`: コンテキスト継続

**Codex CLI**:
- `--continue`: セッションを継続
- `--resume`: 前回の状態から再開

**実装方針**:
- `--` 以降の引数はそのまま選択されたツールに渡す
- オプション検証は各ツール側で実施
- claude-worktreeは透過的なプロキシとして動作

### 4. タイムアウト処理

**決定**: タイムアウトは実装しない
**根拠**:
- ユーザーの意図的な選択を待つべき
- 誤操作によるデフォルト起動を防ぐ
- シンプルな実装を維持

**代替案**:
- 30秒タイムアウト: ユーザーを急かす
- デフォルト選択: 意図しない動作の可能性

### 5. inquirerの使用方法

**決定**: `@inquirer/prompts` の `select` 関数を使用
**根拠**:
- 最新のモジュラーAPI
- TypeScript完全対応
- 軽量で必要な機能のみインポート
- qキーでのキャンセルをネイティブサポート

**実装詳細**:
- 選択肢の表示: 矢印キーで移動
- 確定: Enterキー
- キャンセル: qキーまたはCtrl+C
- キャンセル時は終了コード130で終了

**代替案**:
- 旧inquirer: 全体をインポートする必要
- 自作プロンプト: 再発明の必要なし

### 6. エラーハンドリング

**決定**: 明確なエラーメッセージと回復オプション提供
**根拠**:
- ユーザーが次のアクションを理解できる
- デバッグ情報を含める
- 非破壊的なフォールバック

**実装詳細**:
- Codex CLI未インストール: 警告後Claude Codeを提案
- 設定ファイル破損: デフォルト値で続行
- 権限エラー: 具体的な解決方法を表示

### 7. 設定ファイル構造

**決定**: 
```json
{
  "version": "1.0.0",
  "defaultTool": "claude",
  "lastSelection": "claude",
  "selectionHistory": [
    {
      "tool": "claude",
      "timestamp": "2025-01-06T10:00:00Z",
      "args": ["-r"]
    }
  ],
  "preferences": {
    "rememberSelection": true,
    "showWelcomeMessage": true
  }
}
```

**根拠**:
- 将来の拡張性を確保
- バージョン管理で移行を容易に
- 使用統計の収集が可能
- ツール固有の引数履歴も保存

### 8. 依存関係管理

**決定**: 最小限の依存を維持
- `@inquirer/prompts`: 対話型UI
- `chalk`: カラフルな出力
- `fs-extra`: ファイル操作のユーティリティ
- `yargs`: コマンドライン引数パース（-- サポート用）

**根拠**:
- セキュリティリスクの最小化
- インストール時間の短縮
- メンテナンス負担の軽減

## 技術的制約の解決

### クロスプラットフォーム対応
- Windows: `where` コマンドを使用
- Unix系: `which` コマンドを使用
- Node.jsの `process.platform` で判定

### 非同期処理
- すべてのI/O操作をasync/awaitで実装
- エラー境界を明確に設定
- プロミスチェーンの適切な管理

### パフォーマンス最適化
- 設定ファイルのキャッシュ
- ツール検出結果のメモ化
- 起動時の並列処理

## リスクと緩和策

| リスク | 影響 | 緩和策 |
|--------|------|--------|
| Codex CLI APIの変更 | 統合の破損 | バージョンチェックと互換性レイヤー |
| 設定ファイルの競合状態 | データ損失 | ファイルロックとアトミック書き込み |
| ターミナル互換性 | UI表示問題 | フォールバックテキストモード |
| オプション競合 | 予期しない動作 | -- による明確な境界設定 |

## 次のステップ

1. データモデルの詳細設計
2. CLIコントラクトの定義
3. テストシナリオの作成
4. 実装タスクの生成

---
*すべての NEEDS CLARIFICATION を解決済み*
