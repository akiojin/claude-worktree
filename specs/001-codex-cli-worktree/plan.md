# 実装計画: Codex CLI対応（worktree起動時のツール選択）

**ブランチ**: `001-codex-cli-worktree` | **日付**: 2025-01-06 | **仕様**: [spec.md](./spec.md)
**入力**: `/specs/001-codex-cli-worktree/spec.md` の機能仕様

## 実行フロー（/plan コマンドの範囲）
```
1. 入力パスから機能仕様を読み込む
   → 見つからない場合: ERROR "{path} に機能仕様がありません"
2. 技術コンテキストを埋める（NEEDS CLARIFICATION を走査）
   → 文脈からプロジェクト種別を検出（web=frontend+backend、mobile=app+api）
   → 種別に基づき構成方針（Structure Decision）を設定
3. 下記の「憲章チェック」を評価
   → 違反がある場合: 複雑性トラッキングに記録
   → 正当化できない場合: ERROR "まずアプローチを単純化してください"
   → 進捗トラッキングを更新: 初回の憲章チェック
4. フェーズ0を実行 → research.md
   → NEEDS CLARIFICATION が残る場合: ERROR "不明点を解消してください"
5. フェーズ1を実行 → contracts、data-model.md、quickstart.md、エージェント別テンプレートファイル
6. 憲章チェックを再評価
   → 新たな違反があれば: 設計をリファクタしフェーズ1へ戻る
   → 進捗トラッキングを更新: 設計後の憲章チェック
7. フェーズ2の計画 → タスク生成アプローチを記述（tasks.md は作成しない）
8. STOP - /tasks コマンドの準備完了
```

**重要**: /plan コマンドは手順7で停止します。フェーズ2〜4は別コマンドが実行します:
- フェーズ2: /tasks コマンドが tasks.md を生成
- フェーズ3-4: 実装の実行（手動またはツール）

## 要約
worktree起動時にAIアシスタントツール（Claude CodeまたはCodex CLI）を選択できる機能を実装する。CLIベースの対話型選択インターフェースを提供し、選択されたツールでworktree環境を初期化する。

## 技術コンテキスト
**言語/バージョン**: Node.js 18+ / TypeScript 5.0+  
**主要依存**: inquirer（対話型プロンプト）、chalk（ターミナル出力）  
**ストレージ**: ローカルファイル（設定保存用）  
**テスト**: Jest / Vitest  
**ターゲットプラットフォーム**: Linux/macOS/Windows ターミナル環境
**プロジェクト種別**: single（CLIツール）  
**性能目標**: 起動時選択 < 100ms、選択UI応答 < 50ms  
**制約**: ターミナルの標準入出力のみ使用、非同期処理  
**規模/範囲**: 単一機能追加、既存worktreeへの拡張

## 憲章チェック
*GATE: フェーズ0の調査前に合格必須。フェーズ1設計後に再チェック。*

**シンプルさ**:
- プロジェクト数: 1（CLIツール単体）
- フレームワークを直接使用？ ✓（inquirer直接使用）
- 単一データモデル？ ✓（選択設定のみ）
- パターン濫用を回避？ ✓（シンプルな手続き的実装）

**アーキテクチャ**:
- すべての機能はライブラリ化？ ✓（tool-selector ライブラリ）
- ライブラリ一覧: 
  - tool-selector: AIツール選択と初期化を管理
- ライブラリごとに CLI 提供: 
  - `worktree --help`
  - `worktree --version`
  - `worktree --tool <claude|codex>`（直接指定オプション）
- ライブラリドキュメント: llms.txt 形式を計画 ✓

**テスト（非交渉）**:
- RED→GREEN→リファクタのサイクル強制？ ✓
- Git の履歴に実装前のテストが残る？ ✓
- 順序: Contract→Integration→E2E→Unit を厳守？ ✓
- 実物依存を使用？ ✓（実際のファイルシステム）
- 統合テスト: 新規ライブラリ、契約変更、共有スキーマを網羅？ ✓
- 禁止事項: テスト前実装、RED フェーズ省略

**可観測性**:
- 構造化ログを含む？ ✓（選択のログ記録）
- フロントのログ→バックエンド集約？ N/A（CLIツール）
- エラー文脈は十分？ ✓（選択エラー、ツール利用不可エラー）

**バージョニング**:
- バージョン番号付与？ ✓（package.jsonで管理）
- 変更ごとに BUILD を増分？ ✓
- 破壊的変更の扱い？ ✓（既存のworktree動作は維持）

## プロジェクト構成

### ドキュメント（本機能）
```
specs/001-codex-cli-worktree/
├── plan.md              # 本ファイル（/plan コマンド出力）
├── research.md          # フェーズ0の出力（/plan コマンド）
├── data-model.md        # フェーズ1の出力（/plan コマンド）
├── quickstart.md        # フェーズ1の出力（/plan コマンド）
├── contracts/           # フェーズ1の出力（/plan コマンド）
└── tasks.md             # フェーズ2の出力（/tasks コマンド - /plan では作らない）
```

### ソースコード（リポジトリルート）
```
# オプション1: 単一プロジェクト（選択）
src/
├── models/
│   └── tool-selection.ts
├── services/
│   └── tool-selector.ts
├── cli/
│   └── worktree.ts
└── lib/
    └── tool-selector/

tests/
├── contract/
├── integration/
└── unit/
```

**構成方針**: オプション1（単一プロジェクト）- CLIツールのため

## フェーズ0: 叩き台 & 調査
1. 技術コンテキストから不明点を抽出:
   - Codex CLIの利用可能性チェック方法
   - 選択の永続化（セッション vs 永続）
   - コマンドラインオプションの設計
   - タイムアウト処理の必要性

2. 調査エージェントを生成して配布:
   - Codex CLIの環境確認方法の調査
   - inquirerのベストプラクティス調査
   - 設定ファイルの保存場所の標準

3. `research.md` に所見を集約

**出力**: すべての NEEDS CLARIFICATION を解消した research.md

## フェーズ1: 設計 & 契約
*前提: research.md 完了*

1. 機能仕様からエンティティを抽出 → `data-model.md`:
   - ToolSelection: 選択されたツールと設定
   - ToolConfig: デフォルト設定と履歴

2. API契約を生成:
   - CLI コマンドインターフェース仕様
   - 設定ファイルフォーマット

3. 契約に基づくコントラクトテストを生成:
   - CLI引数のテスト
   - 設定ファイルの読み書きテスト

4. ユーザーストーリーからテストシナリオを抽出:
   - 初回起動時の選択フロー
   - 選択の記憶と再利用
   - エラーハンドリング

5. エージェントファイルを漸進的に更新:
   - CLAUDE.md の更新

**出力**: data-model.md、/contracts/*、失敗するテスト、quickstart.md、CLAUDE.md

## フェーズ2: タスク計画アプローチ
*この節は /tasks コマンドが実施する内容の説明です - /plan 中は実行しない*

**タスク生成戦略**:
- ツール選択モデルの作成 [P]
- CLIインターフェースの拡張
- 設定管理の実装
- 統合テストの作成
- エラーハンドリングの実装

**順序戦略**:
- TDD 順: テスト→実装
- 依存順: モデル→サービス→CLI
- 並列実行可のものに [P] を付与

**想定出力**: tasks.md に 15〜20個の番号付きタスク

**重要**: このフェーズは /tasks コマンドが実行します（/plan では実行しません）

## フェーズ3+: 将来の実装
*これらのフェーズは /plan コマンドの範囲外です*

**フェーズ3**: タスク実行（/tasks コマンドが tasks.md を作成）  
**フェーズ4**: 実装（憲章原則に従って tasks.md を実行）  
**フェーズ5**: 検証（テスト実行、quickstart.md 実行、性能検証）

## 複雑性トラッキング
*憲章チェックに違反がある場合のみ記入*

違反なし - シンプルな設計を維持

## 進捗トラッキング
*実行フロー中に更新されるチェックリスト*

**フェーズステータス**:
- [x] フェーズ0: 調査完了（/plan コマンド）
- [x] フェーズ1: 設計完了（/plan コマンド）
- [x] フェーズ2: タスク計画完了（/plan コマンド - アプローチのみ記述）
- [ ] フェーズ3: タスク生成済み（/tasks コマンド）
- [ ] フェーズ4: 実装完了
- [ ] フェーズ5: 検証合格

**ゲートステータス**:
- [x] 初回の憲章チェック: PASS
- [x] 設計後の憲章チェック: PASS
- [x] すべての NEEDS CLARIFICATION 解決済み
- [x] 複雑性の逸脱を文書化

---
*憲章 v2.1.1 に基づく - `/memory/constitution.md` を参照*