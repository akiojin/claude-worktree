
計画を実行可能なタスクへ分解します。

これは Spec-Driven Development ライフサイクルの3番目のステップです。

引数で与えられたコンテキストに基づき、次を実施します:

1. リポジトリルートで `scripts/check-task-prerequisites.sh --json` を実行し、FEATURE_DIR と AVAILABLE_DOCS のリストを取得する。すべてのパスは絶対パスにすること。
2. 利用可能な設計ドキュメントを読み込み・分析する:
   - 常に plan.md を読み、技術スタックとライブラリを確認
   - 存在すれば: data-model.md を読み、エンティティを確認
   - 存在すれば: contracts/ を読み、API エンドポイントを確認  
   - 存在すれば: research.md を読み、技術的決定事項を確認
   - 存在すれば: quickstart.md を読み、テストシナリオを確認
   
   注: すべてのプロジェクトがすべてのドキュメントを持つとは限らない。例:
   - CLI ツールは contracts/ を持たない場合がある
   - シンプルなライブラリは data-model.md を必要としない場合がある
   - 利用可能なものに基づいてタスクを生成する

3. テンプレートに従ってタスクを生成する:
   - `/templates/tasks-template.md` をベースとして使用
   - サンプルタスクを、以下に基づく実タスクへ置換:
     - **セットアップタスク**: プロジェクト初期化、依存、Lint
     - **テストタスク [P]**: 契約ごとに1件、統合シナリオごとに1件
     - **コアタスク**: エンティティ、サービス、CLI コマンド、エンドポイントごと
     - **連携タスク**: DB 接続、ミドルウェア、ロギング
     - **仕上げタスク [P]**: ユニットテスト、性能、ドキュメント

4. タスク生成ルール:
   - 契約ファイルごと → [P] の付いたコントラクトテストタスク
   - データモデル中の各エンティティ → [P] の付いたモデル作成タスク
   - 各エンドポイント → 実装タスク（共有ファイルの場合は並列不可）
   - 各ユーザーストーリー → [P] の付いた統合テスト
   - 異なるファイル = 並列可 [P]
   - 同一ファイル = 逐次（[P] なし）

5. 依存関係に基づきタスクを整列:
   - すべてに先立ちセットアップ
   - 実装より前にテスト（TDD）
   - モデルの後にサービス
   - サービスの後にエンドポイント
   - コアの後に連携
   - すべての後に仕上げ

6. 並列実行例を含める:
   - 併走できる [P] タスクをグループ化
   - 実際の Task エージェントコマンドを示す

7. FEATURE_DIR/tasks.md を作成し、以下を含める:
   - 実装計画に一致する正しい機能名
   - 連番タスク（T001, T002, ...）
   - 各タスクの明確なファイルパス
   - 依存関係の注記
   - 並列実行のガイダンス

タスク生成のコンテキスト: $ARGUMENTS

tasks.md は即時に実行可能であるべきです。各タスクは、追加文脈なしで LLM が完了できる具体性を備えてください。
